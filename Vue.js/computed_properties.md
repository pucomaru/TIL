# Vue.js 정리 노트

---

## ✅ computed()

"계산된 속성"을 정의하는 함수
→ 미리 계산된 속성을 사용하여 템플릿에서 표현식을 단순하게 하고 불필요한 반복 연산을 줄임

### 📌 특징

* 반환되는 값은 computed ref이며 일반 refs와 유사하게 계산된 결과를 `.value`로 참조할 수 있음 (템플릿에서는 `.value` 생략 가능)
* computed 속성은 의존된 반응형 데이터를 **자동으로 추적**
* 의존하는 데이터가 **변경될 때만 재평가**됨

### 📌 computed vs methods 차이

| 항목    | computed                      | methods                |
| ----- | ----------------------------- | ---------------------- |
| 목적    | 계산된 값(Calculated property) 반환 | 기능(행동) 실행              |
| 캐싱 여부 | ✅ 값이 변하지 않으면 **캐싱**됨          | ❌ 호출할 때마다 **새로 실행**됨   |
| 실행 시점 | 템플릿에서 **자동 실행 (반응형)**         | 호출할 때마다 **수동 실행**됨     |
| 사용 용도 | 템플릿에서 동적으로 변하는 **값 표시**       | 버튼 클릭 등 이벤트로 **기능 실행** |

### 📌 Cache(캐시)

* 데이터나 결과를 일시적으로 저장해두는 임시 저장소
* 이후에 같은 데이터나 결과를 다시 계산하지 않고 빠르게 접근할 수 있도록 함

### 📌 적절한 사용처

* **computed**:

  * 의존하는 데이터에 따라 결과가 바뀌는 계산된 속성을 만들 때 유용
  * 동일한 의존성을 가진 여러 곳에서 사용할 때 계산 결과를 캐싱하여 중복 계산 방지
* **method**:

  * 단순히 특정 동작을 수행하는 함수 정의 시
  * 데이터 의존과 관계없이 항상 동일한 결과 반환

---

## ✅ v-if / v-show / v-else / v-else-if

* `v-if`: 표현식 값의 true/false를 기반으로 요소를 조건부 렌더링
* `v-else`: `v-if`에 대한 else 블록
* `v-else-if`: `v-if`에 대한 else if 블록
* `v-show`: 표현식 값의 true/false에 따라 CSS로 가시성을 전환

### 📌 차이 정리

| 항목     | v-if                    | v-show               |
| ------ | ----------------------- | -------------------- |
| 렌더링 방식 | 조건이 true일 때 **DOM 생성**  | 항상 렌더링되고 **CSS로 숨김** |
| 초기 렌더링 | 조건이 false면 **아예 생성 안됨** | 처음부터 **DOM에 있음**     |
| 토글 성능  | ❌ 토글 시마다 DOM 재생성        | ✅ 토글 시 빠름 (단순 CSS)   |
| 사용 용도  | 자주 바뀌지 않는 조건            | 자주 바뀌는 조건            |

### 📌 언제 어떤 걸 써야 하나?

| 상황                                      | 추천 디렉티브      |
| --------------------------------------- | ------------ |
| 요소가 **자주 보였다 숨겨졌다** 한다면                 | v-show (빠름)  |
| 조건이 **드물게 바뀌거나 무거운 컴포넌트**일 경우           | v-if (성능 절약) |
| 초기 렌더링 시 조건을 만족하지 않는 요소는 아예 안 보이게 하고 싶다 | v-if         |

---

## ✅ v-for

* 소스 데이터를 기반으로 요소 또는 템플릿 블록을 화면에 반복적으로 렌더링

### 📌 key 사용하기

* Vue에서는 반드시 `v-for`와 `key`를 함께 사용
* 내부 컴포넌트의 상태를 일관되게 하여 데이터의 예측 가능한 행동 유지
* key는 반드시 각 요소에 대한 **고유한 값을 나타낼 수 있는 식별자**여야 함 (인덱스 말고 고유한 값)

#### 📌 올바른 key 선택 기준

* 권장: 데이터베이스 고유 ID, UUID 등
* 피해야 할 값: 배열 인덱스, 객체 자체

> 동일 요소에 `v-for`와 `v-if`를 함께 사용하지 않는다.
> `v-if`가 `v-for`보다 우선순위가 더 높기 때문
> 👉 해결법: 요소를 나누거나 `computed`를 이용해 조건 필터링

---

## ✅ watch()

* 하나 이상의 반응형 데이터를 감시하고 감시하는 데이터가 변경되면 콜백 함수를 호출

```js
watch(source, (newValue, oldValue) => {
  // do something
})
```

* 첫 번째 인자 (source): 감시하는 대상 (반응형 변수, 값을 반환하는 함수 등)
* 두 번째 인자 (callback): 변경 시 실행될 함수

  * newValue: 변화된 값
  * oldValue (optional): 기존 값

---

## ✅ computed vs watch

| 항목    | computed                 | watch (watcher)            |
| ----- | ------------------------ | -------------------------- |
| 목적    | **계산된 값을 반환** (템플릿에서 사용) | 데이터 변화에 따라 **함수 실행**       |
| 결과    | 값을 반환함                   | 아무 것도 반환하지 않음              |
| 실행 시점 | 종속된 데이터가 바뀌면 자동 재계산      | 지정한 데이터가 바뀌면 **콜백 함수 실행**  |
| 캐싱    | ✅ 캐싱됨 (같은 값이면 재계산 안 함)   | ❌ 캐싱 없음 (값 바뀔 때마다 실행)      |
| 사용 위치 | 주로 **템플릿에서 값 계산**        | **비동기 처리, API 호출, 사이드이펙트** |

### 📌 언제 어떤 걸 써야 할까?

| 상황                      | 추천 도구    |
| ----------------------- | -------- |
| 템플릿에 보여줄 계산된 값이 필요할 때   | computed |
| 데이터가 바뀔 때 로직/행동이 필요할 때  | watch    |
| 캐싱된 값을 재활용하고 싶을 때       | computed |
| API 호출, 비동기 처리, 로그 출력 등 | watch    |

> 🔹 computed: **값이 필요한 상황**
> 🔹 watch: **행동이 필요한 상황**
> ✅ computed와 watch 모두 의존(감시)하는 원본 데이터를 직접 변경하지 않음

---

## ✅ Lifecycle Hooks

Vue 컴포넌트의 생성부터 소멸까지 각 단계에서 실행되는 함수

### 📌 주요 Lifecycle Hooks

* 생성 단계 / 마운트 단계 / 업데이트 단계 / 소멸 단계 등
* 자주 쓰는 훅: `onMounted`, `onUpdated`, `onUnmounted`

### 📌 Mounting 단계 예시

* Vue 컴포넌트 인스턴스가 초기 렌더링 및 DOM 요소 생성이 완료된 후 특정 로직을 수행

---

### 📌 참고

1. `computed`의 반환 값은 **변경하지 말 것**

   * computed는 의존하는 데이터의 파생된 값 (snapshot)
   * 변경하려면 원본 데이터를 수정해야 함
2. `computed` 사용 시 **원본 배열 직접 수정 금지**

   * `filter()`, `map()`, `slice()` 등 새 배열 반환 방식 사용

---

# Vue.js에서 `<template>`을 왜 써야 할까?

Vue.js에서 `<template>` 태그는 **컴포넌트가 화면에 어떤 구조로 보일지를 정의**하는 영역이다.
단순히 HTML을 작성하는 용도가 아니라, Vue의 렌더링 시스템과 밀접한 관련이 있다.

---

## ✅ `<template>`의 역할

* Vue 컴포넌트의 **화면 구조(HTML)** 를 정의하는 곳
* **데이터와 연결**되어 화면이 동적으로 바뀜
* Vue가 내부적으로 **Virtual DOM을 생성**하기 위한 기반 구조

---

## ✅ 왜 `<body>`나 그냥 HTML로 안 되는가?

| 항목       | `<body>`에 직접 작성 | `<template>` 사용                      |
| -------- | --------------- | ------------------------------------ |
| 동작 방식    | 브라우저가 바로 렌더링    | Vue가 가상 DOM으로 해석 후 렌더링               |
| 구조 분리    | ❌ (HTML/JS 혼합)  | ✅ (`template`, `script`, `style` 분리) |
| 컴포넌트 재사용 | ❌ 어려움           | ✅ 컴포넌트화 가능                           |
| 유지보수     | ❌ 힘듦            | ✅ 효율적                                |

---

## ✅ 언제 렌더링되나?

* Vue 컴포넌트가 **`mount()` 될 때**
* `<template>` 자체는 화면에 나타나지 않고,
  내부 HTML 구조만 Vue가 가져와 **실제 DOM에 반영(rendering)** 됨

---

## ✅ `<template>` 태그의 특징

| 특징           | 설명                                                |
| ------------ | ------------------------------------------------- |
| 렌더링 X        | `<template>` 자체는 브라우저 화면에 표시되지 않음                 |
| 최상위 태그 1개 필수 | `<template>` 안에는 반드시 하나의 루트 요소가 있어야 함             |
| 데이터 바인딩      | `{{ message }}`와 같이 Vue의 데이터와 연결 가능               |
| 가상 DOM 기반    | Vue는 `<template>`을 바탕으로 Virtual DOM을 만들고 효율적으로 갱신 |

## ✅ 요약

> Vue의 `<template>`은
> 단순한 HTML 작성 공간이 아니라
> **Vue 컴포넌트의 화면 구조를 정의하고 가상 DOM을 생성하는 핵심 역할을 한다.**

---

## ✅ 배열 변경 관련 메서드

### 1. 변화 메서드 (원본 배열 변경)

* `push()`
* `pop()`
* `shift()`
* `unshift()`
* `splice()`
* `sort()`
* `reverse()`

### 2. 배열 교체 (새 배열 반환)

* `filter()`
* `concat()`
* `slice()`
