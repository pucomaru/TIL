
# Vue.js 정리 노트



## ✅ computed()

- "계산된 속성"을 정의하는 함수
- 미리 계산된 속성을 사용하여 템플릿에서 표현식을 단순하게 하고 불필요한 반복 연산을 줄임

###  특징
- 반환되는 값은 computed ref이며 `.value`로 참조 (템플릿에서는 생략 가능)
- 의존된 반응형 데이터를 **자동으로 추적**
- 의존하는 데이터가 **변경될 때만 재평가됨**

### 📌 computed vs methods

| 항목         | `computed`                              | `methods`                                 |
|--------------|------------------------------------------|--------------------------------------------|
| 목적         | 계산된 값(Calculated property) 반환      | 기능(행동) 실행                             |
| 캐싱 여부    | ✅ 값이 변하지 않으면 캐싱됨              | ❌ 호출할 때마다 새로 실행됨                |
| 실행 시점    | 템플릿에서 자동 실행 (반응형)             | 호출 시 수동 실행                           |
| 사용 용도    | 템플릿에서 값 표시용                      | 이벤트 처리, 동작 실행                      |

###  사용 적절성

- `computed`:  
  - 의존 데이터에 따라 결과가 변하는 **계산된 속성**에 적합  
  - 동일한 연산이 여러 곳에서 필요할 때  
- `methods`:  
  - 버튼 클릭 등 **동작**에 적합  
  - 항상 새로운 결과가 필요한 경우

---

##  Cache(캐시)

- 계산된 값이나 데이터를 **임시로 저장**해두는 저장소
- 동일 요청 시 **재계산 없이 빠르게 접근** 가능

---

##  v-if / v-show / v-else / v-else-if

- `v-if`: 조건이 true일 때 요소를 **DOM에 생성**
- `v-else`: v-if의 false 조건일 때 실행
- `v-else-if`: 여러 조건 중 하나
- `v-show`: DOM은 항상 존재하고 **CSS `display: none`** 으로 숨김

### 📌 v-if vs v-show

| 항목        | `v-if`                          | `v-show`                       |
|-------------|----------------------------------|--------------------------------|
| 렌더링 방식 | 조건이 true일 때 DOM 생성        | 항상 렌더링, CSS로 숨김         |
| 초기 렌더링 | 조건이 false면 아예 생성 안 됨    | 처음부터 DOM에 있음             |
| 토글 성능   | ❌ 느림 (DOM 재생성)             | ✅ 빠름 (CSS 토글)              |
| 사용 용도   | 드물게 바뀌는 조건                | 자주 토글되는 조건              |

---

##  v-for

- 소스 데이터를 기반으로 요소 또는 템플릿 블록을 반복 렌더링
- 반드시 `key` 속성과 함께 사용해야 **Vue가 요소를 추적** 가능

### 📌 key 사용 시 주의사항

- ✅ 고유 식별자 (예: 데이터베이스 ID, UUID 등)
- ❌ 피해야 할 값: 배열 인덱스, 객체 자체

### 📌 v-for와 v-if를 같이 쓰면 안 되는 이유

- 같은 요소에 사용하면 우선순위 충돌 발생 (`v-if`가 우선)
- ➡️ 해결 방법: `computed`로 필터링하여 v-for만 사용

---

##  watch()

- 하나 이상의 반응형 데이터를 감시하고, 데이터 변경 시 **콜백 함수 실행**

```js
watch(source, (newValue, oldValue) => {
  // do something
})
````

* `source`: 감시할 대상 (ref, 함수 등)
* `callback`: 값이 변경되면 실행되는 함수

---

## ✅ computed vs watch

| 항목    | `computed`        | `watch`                 |
| ----- | ----------------- | ----------------------- |
| 목적    | 계산된 값을 반환         | 값이 바뀔 때 로직 실행           |
| 반환값   | O                 | X                       |
| 실행 시점 | 의존 데이터 변경 시 자동 계산 | 감시 대상 변경 시 수동 실행        |
| 캐싱    | ✅ 있음              | ❌ 없음                    |
| 사용 용도 | 화면 출력용 계산값        | 비동기 처리, API 호출 등 사이드이펙트 |

> 🔹 `computed`: 값이 필요한 상황
> 🔹 `watch`: 동작이 필요한 상황
> 🔸 둘 다 원본 데이터를 직접 변경하지 않음

---

##  Lifecycle Hooks

Vue 컴포넌트의 **생성 → 마운트 → 업데이트 → 소멸** 과정에서 특정 시점마다 실행할 수 있는 함수

###  자주 쓰는 훅

* `onMounted()`: DOM 마운트 직후 실행 (API 호출, 초기 작업)
* `onUpdated()`: 컴포넌트 업데이트 후 실행
* `onUnmounted()`: 제거 직전 정리 작업

---

## ✅ `<template>`을 왜 써야 하나?

Vue 컴포넌트의 **화면 구조**를 정의하는 부분. 브라우저에는 보이지 않음.

###  역할

* HTML 구조 정의
* Vue가 **Virtual DOM**을 만들기 위한 설계도

### 📌 `<body>`와의 비교

| 항목       | `<body>` 직접 작성 | `<template>` 사용                |
| -------- | -------------- | ------------------------------ |
| 동작 방식    | 브라우저가 바로 렌더링   | Vue가 해석해서 Virtual DOM 생성       |
| 구조 분리    | ❌ 불가능          | ✅ template / script / style 분리 |
| 컴포넌트 재사용 | ❌ 어려움          | ✅ 가능                           |
| 유지보수     | ❌ 불편함          | ✅ 편리함                          |

### 특징

* 최상위 태그 1개만 있어야 함
* 실제 브라우저에는 `<template>` 태그는 보이지 않음
* 내부 내용만 Virtual DOM으로 변환됨

##  배열 관련 메서드

### 1. 원본 배열을 **변경**하는 메서드 (mutation)

* `push()`, `pop()`, `shift()`, `unshift()`, `splice()`, `sort()`, `reverse()`

### 2. 원본 배열을 **변경하지 않고 새 배열을 반환**하는 메서드 (non-mutation)

* `filter()`, `concat()`, `slice()`

---

##  computed 주의사항

1. `computed`의 반환 값은 **읽기 전용**
   → 값을 직접 수정하면 안 됨. 데이터 자체를 수정해야 함.

2. `computed`에서 원본 배열을 **직접 수정하지 말 것**
   → `map()`, `filter()` 등 **새 배열 반환 방식 사용** 추천

```

---

필요하면 이걸 PDF로 변환하거나 GitHub에 업로드할 형식으로도 도와줄게!
```
