
# 단축키

- `Ctrl + W`
  - 단어 선택 단축키
  - 이 단축키를 누르면 현재 커서 위치에서 단어 단위로 선택 영역이 확장된다.

- `Alt + Enter`
  - 빠른 수정 + 자동 완성 단축키

- `Shift`
  - Shift 누르고 class 누르면 중복 선택 가능하다.

---

# 자바 메모리 구조

- **메서드 영역**
  - 클래스 정보를 보관한다.
  - 프로그램 실행에 필요한 공통 데이터를 관리하며, 모든 영역에서 공유한다.
  - 클래스 정보: 클래스의 실행 코드, 필드, 메서드, 생성자 코드 등 모든 실행 코드가 존재.
  - static 영역: static 변수들을 보관.
  - 런타임 상수 풀: 프로그램 실행에 필요한 공통 리터럴 상수를 보관.

- **스택 영역**
  - 실제 프로그램이 실행되는 영역.
  - 자바 실행 시 하나의 실행 스택이 생성된다.

- **힙 영역**
  - 객체(인스턴스)와 배열이 생성되는 영역.
  - `new` 명령어로 객체(인스턴스)가 생성된다.
  - 가비지 컬렉션(GC)이 수행되는 주요 영역으로, 참조되지 않는 객체는 GC에 의해 제거된다.

- 메서드는 메서드 영역에서 공통으로 관리되고 실행된다.
- 지역 변수는 스택 영역에, 객체(인스턴스)는 힙 영역에 관리된다.

---

# static 키워드

- static 키워드는 주로 멤버 변수와 메서드에 사용된다.
- static을 사용하면 공용으로 사용하는 변수를 만들 수 있다.

- **static 멤버 변수**
  - 멤버 변수에 static이 붙으면 static 변수(정적 변수, 클래스 변수)라고 부른다.
  - static 변수는 메서드 영역에서 관리된다.
  - static 변수는 인스턴스 영역에 생성되지 않는다.

---

# 멤버 변수(필드)의 종류

- **인스턴스 변수**
  - static이 없는 멤버 변수.
  - 인스턴스를 생성해야 사용할 수 있으며, 인스턴스에 소속된다.
  - 인스턴스를 생성할 때마다 새로 만들어진다.

- **클래스 변수**
  - static이 붙은 멤버 변수.
  - 클래스 변수, 정적 변수, static 변수 등 다양한 이름으로 불린다.
  - 인스턴스와 무관하게 클래스 자체에 소속되어 있으며, 프로그램 시작 시 딱 하나가 생성된다.
  - 여러 곳에서 공유 목적으로 사용된다.

- static 변수는 클래스명으로 바로 접근 가능하지만, 인스턴스로도 접근할 수 있다.
  - 하지만 인스턴스로 접근하는 것은 권장되지 않는다.
  - 이유: 코드 읽을 때 인스턴스 변수처럼 보일 수 있어서 오해가 발생할 수 있다.

---

# 메서드 종류

- **클래스 메서드**
  - 메서드 앞에 static을 붙인 메서드.
  - 정적 메서드 또는 클래스 메서드라고 부른다.
  - 객체 생성 없이 `클래스명.메서드명()` 형태로 호출 가능.
  - 불필요한 객체 생성 없이 편리하게 사용된다.

- **인스턴스 메서드**
  - static이 없는 메서드.
  - 인스턴스를 생성한 뒤 호출할 수 있다.

- static 메서드는 언제나 사용할 수 있는 것이 아님.
  - static 메서드는 static 변수만 사용할 수 있다.
  - 반면, 모든 곳에서 static을 호출할 수 있다.

---

# static import

- static 메서드를 자주 호출할 경우 `static import` 기능을 사용하면 코드가 간결해진다.

---

# final 변수

- 변수에 final 키워드를 붙이면 더 이상 값을 변경할 수 없다.
- 지역 변수에 final을 붙이면 최초 한 번만 할당 가능.
  - 이후 값을 변경하려 하면 컴파일 오류 발생.
- 매개변수에 final을 붙이면 메서드 내부에서 해당 매개변수 값을 변경할 수 없다.

---

# static final

- 필드 초기화 시, 모든 인스턴스가 동일한 값을 사용하면 메모리를 낭비할 수 있다.
- static final을 사용하면 메서드 영역(static 영역)에 단 하나만 존재하게 된다.
- 따라서 효율적으로 관리할 수 있다.

---

# 상수

- 변하지 않고 항상 일정한 값을 갖는 수를 상수라고 한다.
- 자바에서 상수는 고정된 값이다.

---

# 자바 상수 특징

- static final 키워드를 사용한다.
- 대문자 + 언더스코어(_)로 표기한다.
  - 일반 변수와 상수를 구분하기 위해 사용.
- 필드에 직접 접근해서 사용한다.
  - 상수는 값 자체를 사용하는 것이 목적이므로 메서드를 호출하지 않고 직접 접근해도 안전하다.
  - 값을 변경할 수 없으므로 직접 접근 시 데이터가 변하지 않는다.

---

# 상속 관계

- 상속은 객체 지향 프로그래밍의 핵심 요소 중 하나로, 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용한다.
- `extends` 키워드를 사용하여 상속을 구현한다.
  - 단일 상속만 지원한다. (부모 클래스는 하나만 선택 가능)
- 부모 클래스(슈퍼 클래스)
  - 상속을 통해 자신의 필드와 메서드를 제공한다.
- 자식 클래스(서브 클래스)
  - 부모 클래스로부터 필드와 메서드를 상속받는다.
- 부모 클래스는 자식 클래스에 접근할 수 없다.

- 상속 관계 객체 생성 시, 부모와 자식 클래스가 함께 생성된다.
  - 외부에서는 하나의 객체처럼 보이지만 내부에서는 부모와 자식 모두 생성되며 메모리가 구분된다.
- 메서드 호출 시, 호출하는 변수의 타입(클래스)을 기준으로 메서드를 찾는다.
  - 본인 타입에 없으면 부모 타입에서 찾는다.

- 상속과 메모리 구조는 반드시 이해해야 한다.
  - 상속 관계의 객체 생성 시 부모와 자식이 함께 생성된다.
  - 메서드 호출 시 호출자의 타입을 기준으로 대상 메서드를 찾는다.
  - 현재 타입에 없으면 부모 타입으로 올라가서 찾는다.
  - 기능을 찾지 못하면 컴파일 오류가 발생한다.

---

# 메서드 오버라이딩

- 부모에게서 상속받은 메서드를 자식이 재정의하는 것.
- `@Override` 애노테이션을 붙여 상위 클래스 메서드를 오버라이드한다.
  - 선택 사항이지만 코드의 명확성을 위해 붙이는 것이 좋다.

---

# 오버로딩과 오버라이딩

- **오버로딩**
  - 메서드 이름은 같지만 매개변수가 다른 메서드를 여러 개 정의.
- **오버라이딩**
  - 상위 클래스의 메서드를 자식 클래스에서 재정의.

---

# 메서드 오버라이딩 조건

- 메서드 이름, 매개변수 타입/순서/개수 동일해야 함.
- 반환 타입 동일해야 함.
- 접근 제어자는 부모 메서드보다 더 제한적일 수 없다.
- 부모 메서드보다 더 많은 체크 예외를 `throws`로 선언할 수 없다.
- static, final, private 키워드가 붙은 메서드는 오버라이딩 불가.
- 생성자는 오버라이딩 불가.
- 오버라이딩은 인스턴스 레벨에서 사용된다.

---

# UML 표기법

- `+`: public
- `#`: protected
- `~`: default
- `-`: private

---

# super 키워드 (부모 참조)

- 부모와 자식의 필드명이 같거나 메서드가 오버라이딩된 경우, 자식에서 부모의 필드/메서드 호출 시 `super`를 사용한다.

---

# super 생성자 호출

- 상속 관계 객체 생성 시 부모와 자식 클래스가 각각 생성되므로 생성자도 각각 호출된다.
- 자식 클래스 생성자에서 부모 생성자를 반드시 호출해야 한다.
  - `super(...)`를 사용해 호출.
- 생성자 호출 순서: 부모 → 자식
  - 부모 데이터 초기화 → 자식 데이터 초기화 순서로 진행.
- 자식 클래스의 생성자 첫 줄에 `super()`를 반드시 호출해야 한다.
  - 단, 기본 생성자인 경우 생략 가능.
