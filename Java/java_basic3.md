
# Java 클래스와 객체 정리 노트

---

## 단축키 (IntelliJ IDEA)

* **Ctrl + Alt + V** : 어떤 표현식(값)이나 객체를 변수로 자동으로 뽑아내어 선언해주는 기능
* **shift + F6** : 선택한 변수, 메서드, 클래스, 패키지 등의 이름을 한 번에 바꿀 수 있는 단축키
* **alt + insert** : 제너레이터 단축키 (클래스, 메서드 등 자동 생성)

---

## 클래스에 정의한 변수들

* **멤버 변수(Member Variable)**
  * 특정 클래스에 소속된 변수
* **필드(Field)**
  * 데이터 항목을 가리키는 전통적인 용어
* 자바에서 '멤버 변수'와 '필드'는 같은 의미로 사용된다.

---

## 클래스 이름 작성 관례

* 클래스는 대문자로 시작하고 낙타 표기법 사용
  * 예시: `Student`, `User`, `MemberService`

---

## 클래스와 객체

* **클래스(Class)**
  * 객체를 생성하기 위한 틀(설계도)
  * 객체가 가져야 할 속성(변수)과 기능(메서드)를 정의
* **객체(Object)**
  * 클래스에서 정의한 속성과 기능을 가진 실체
  * 객체는 서로 독립적인 상태를 가짐
* **인스턴스(Instance)**
  * 특정 클래스에서 생성된 객체
  * 객체가 어떤 클래스에 속해 있는지를 강조할 때 사용
* 객체와 인스턴스는 둘 다 클래스에서 나온 실체라는 의미로 보통 구분하지 않고 사용한다.

---

## 객체 생성과 참조

* `new Student()` 코드는 메모리에 객체를 생성하지만 이름은 없음
* 객체에 접근하기 위해 반환된 참조값을 변수에 저장

```java
Student student1;
student1 = new Student();
````

---

## 변수와 대입

* 자바에서 대입(=)은 항상 변수에 들어 있는 값을 복사해서 전달
* 변수에는 인스턴스 자체가 아닌 인스턴스의 위치(참조값)만 들어있음
* 대입 시 참조값만 복사됨

---

## 배열 선언 최적화

```java
// 배열 선언과 초기화 방법 1
Student[] students = new Student[]{student1, student2};

// 배열 선언과 초기화를 동시에 더 간단히
Student[] students = {student1, student2};
```

---

## 배열 생성 시 크기 지정

```java
ProductOrder[] products = new ProductOrder[3];
```

* `ProductOrder[]`: ProductOrder 타입 배열 선언
* `new ProductOrder[3]`: 크기가 3인 배열 생성

---

## 배열 크기 지정 이유

* 배열은 고정된 크기의 연속된 메모리 공간을 사용
* 배열 생성 시 크기를 지정하지 않으면 얼마만큼의 공간이 필요한지 알 수 없어서 에러 발생

---

## 배열 크기 생략 시

```java
ProductOrder[] products = new ProductOrder[];
```

* 컴파일 에러 발생 (크기를 알 수 없기 때문)

---

## 배열 생성 시 크기 지정 방법

* 크기를 직접 지정

  ```java
  new ProductOrder[3];
  ```
* 배열 리터럴 사용

  ```java
  ProductOrder[] products = {product1, product2, product3};
  ```

  * 배열 크기를 직접 입력하지 않아도 자동으로 크기 결정

---

## 기본형과 참조형

* 기본형을 제외한 나머지는 모두 참조형

  * 기본형: 소문자 (예: int, long, double, boolean)
  * 클래스: 대문자 (예: Student, String)
  * String은 사실 클래스이므로 참조형. 다만 자주 사용되므로 특별한 편의 기능 제공

---

## 변수의 값 복사

* 자바는 항상 변수의 값을 복사해서 대입한다 (중요)

---

## 기본형과 참조형의 메서드 호출

* 메서드의 매개변수는 값에 의해 전달된다

  * 기본형

    * 값 자체가 복사되어 전달됨
    * 메서드 내부에서 값을 변경해도 호출자의 변수에는 영향 없음
  * 참조형

    * 참조값이 복사되어 전달됨
    * 메서드 내부에서 객체의 멤버 변수를 변경하면 호출자의 객체도 변경됨

---

## 멤버 변수

* 클래스 안에서 선언
* 객체 생성 시 생성되고 객체가 사라질 때까지 유지
* 객체마다 다른 값 가능
* 클래스 전체에서 접근 가능 (접근 제한자에 따라 달라짐)

```java
public class Student {
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

---

## 지역 변수

* 메서드나 블록 안에서 선언
* 메서드 실행 시 생성되고 메서드 종료 시 사라짐
* 메서드 외부에서 접근 불가

```java
public void study() {
    int hours = 3;
    System.out.println(hours);
}
```

---

## 변수의 값 초기화

* 멤버 변수: 자동 초기화

  * 숫자 = 0, boolean = false, 참조형 = null
  * 개발자가 초기값을 직접 지정 가능
* 지역 변수: 수동 초기화

  * 반드시 직접 초기화해야 함

---

## 가비지 컬렉션(GC)

* 아무도 참조하지 않는 인스턴스는 JVM의 GC가 자동으로 메모리에서 제거

---

## static 메서드

* 객체 생성 없이 클래스명.메서드명()으로 호출 가능
* 공통 작업이나 유틸리티 기능에 사용

```java
static void initStudent(Student student, String name, int age, int grade) {
    student.name = name;
    student.age = age;
    student.grade = grade;
}
```

* public이 붙으면 모든 클래스/패키지에서 접근 가능
* public 생략 시 같은 패키지에서만 접근 가능

---

## 절차 지향 프로그래밍

* 프로그램의 흐름을 순차적으로 따르며 처리하는 방식
* 데이터 변경 시 main 부분의 메서드들도 함께 변경해야 함
* 데이터와 기능이 분리되어 유지보수 시 관리 포인트가 2곳으로 늘어남

---

## 객체 지향 프로그래밍

* 실제 세계의 사물이나 사건을 객체로 보고 객체 간 상호작용을 중심으로 프로그래밍
* 클래스는 속성(데이터, 멤버 변수)과 기능(메서드)을 정의할 수 있음
* 객체는 자신의 메서드를 통해 자신의 멤버 변수에 접근

  * 객체의 메서드 내부에서 접근하는 멤버 변수는 객체 자신의 멤버 변수
* 매개변수 이름과 멤버 변수 이름이 같을 때 this를 사용해 구분

  * this는 인스턴스 자신을 가리킴

---

## 생성자

* 객체 생성과 동시에 필요한 초기화를 편리하게 수행
* 메서드와 유사하지만

  * 이름은 클래스 이름과 같음 (첫 글자 대문자)
  * 반환 타입 없음 (비워둠)
* 인스턴스를 생성한 직후 호출됨

```java
new 생성자이름(생성자에 맞는 인수 목록)
new 클래스이름(생성자에 맞는 인수 목록)
```

* 생성자 이름이 클래스 이름이므로 둘 다 맞는 표현

---

## 생성자의 장점

* 중복 호출 제거
* 필수값 입력 보장

---

## 기본 생성자

* 매개변수가 없는 생성자
* 클래스에 생성자가 하나도 없으면 자바 컴파일러가 자동으로 만들어줌
* 생성자가 하나라도 있으면 기본 생성자가 자동으로 만들어지지 않음

---

## 생성자 정리

* 생성자는 반드시 호출되어야 함
* 생성자가 없으면 기본 생성자가 제공됨
* 생성자가 하나라도 있으면 기본 생성자가 제공되지 않음

---

## 생성자 오버로딩과 this()

* 생성자는 메서드 오버로딩처럼 매개변수를 다르게 하여 여러 개를 만들 수 있음
* this()를 사용하면 생성자 내부에서 다른 생성자를 호출 가능
* this() 규칙

  * 반드시 생성자 코드의 첫 줄에만 작성할 수 있음

---

## 접근 제어자 종류

* **private**: 모든 외부 호출을 막는다.
* **default (package-private)**: 같은 패키지 안에서 호출을 허용한다.
* **protected**: 같은 패키지 안에서 호출은 허용한다. 패키지가 달라도 상속 관계의 호출은 허용한다.
* **public**: 모든 외부 호출을 허용한다.
* **private → default → protected → public**

---

## 클래스 레벨의 접근 제어자 규칙

* 클래스 레벨의 접근 제어자는 **public**, **default**만 사용할 수 있다.
* **private**, **protected**는 사용할 수 없다.
* **public** 클래스는 반드시 파일명과 이름이 같아야 한다.
* 하나의 자바 파일에 **public** 클래스는 하나만 등장할 수 있다.
* 하나의 자바 파일에 **default** 접근 제어자를 사용하는 클래스는 무한정 만들 수 있다.

---

## 캡슐화

* 객체 지향 프로그래밍의 중요한 개념 중 하나로, 데이터와 해당 데이터를 처리하는 메서드를 하나로 묶어서 외부에서의 접근을 제한하는 방식
* 객체의 데이터는 객체가 제공하는 기능인 메서드를 통해서만 접근해야 한다.

---

## 패키지 규칙

* 패키지의 이름과 위치는 폴더(디렉토리) 위치와 같아야 한다.(필수)
* 패키지 이름은 모두 소문자를 사용한다. (관례)
* 패키지 이름의 앞 부분에는 일반적으로 회사의 도메인 이름을 거꾸로 사용한다 ex) `com.company.myapp`
