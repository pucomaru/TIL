
# 자바 노트 정리

## 단축키 (IntelliJ IDEA)

- `Ctrl + N`: 클래스 검색
- `Ctrl + E`: 최근에 사용한 파일 보기
- `Ctrl + E` + `Enter`: 가장 최근 파일 열기
- `Ctrl + Space`: 변수 이름 자동완성, 메서드 자동 완성 등 코드 자동 완성

---

## 변수의 종류

- 변수는 선언한 위치에 따라 **지역 변수**, **멤버 변수(클래스 변수, 인스턴스 변수)**로 분류된다.

---

## 지역 변수

- 이름 그대로 특정 지역에서만 사용할 수 있는 변수.
- 특정 지역을 벗어나면 사용할 수 없다.
- 여기서 말하는 특정 지역이 바로 변수가 선언된 코드 블록(`{}`).
- 지역 변수는 자신이 선언된 코드 블록 안에서만 생존하고, 코드 블록을 벗어나면 제거된다.

---

## Java 지역 변수와 중첩 코드 블럭

- **지역 변수(Local Variable)**  
  - 선언된 코드 블럭(`{}`) 안에서만 유효하다.  
  - 코드 블럭을 벗어나면 변수는 사라진다.
- **중첩 코드 블럭**  
  - 코드 블럭 안에 또 다른 코드 블럭(`if`, `for`, `while` 등)을 작성할 수 있다.  
  - 중첩된 코드 블럭 안에서도 외부 블럭의 변수를 그대로 사용할 수 있다.
- **중첩 코드 블럭에서 변수 이름 중복**  
  - 중첩된 코드 블럭 안에서 외부 코드 블럭과 같은 이름의 변수를 새로 선언하면 컴파일 오류가 발생한다.  
  - 대신 외부 변수의 값을 변경하거나 그대로 사용할 수 있다.

---

## 예시 코드

```java
public class ScopeExample {
    public static void main(String[] args) {
        int m = 5; // 외부 블럭에서 선언된 변수

        if (true) {
            // int m = 10;  // 🔥 오류: 이미 외부에 같은 이름의 m이 존재
            m = 10;        // 외부 m의 값을 변경하는 것은 가능
            System.out.println("내부 m: " + m);
        }

        System.out.println("외부 m: " + m);
    }
}
````

---

## 변수의 스코프(Scope)

* 지역 변수는 본인의 코드 블록 안에서만 생존한다.
* 코드 블록을 벗어나면 제거되기 때문에 접근할 수 없다.
* 변수의 접근 가능한 범위를 \*\*스코프(Scope)\*\*라 한다.
* Scope를 번역하면 **범위**라는 뜻이다.
* 변수는 꼭 필요한 범위로 한정해서 사용해야 메모리를 효율적으로 사용하고 유지보수가 쉬워진다.
* 좋은 프로그램은 무한한 자유가 있는 프로그램이 아니라 적절한 제약이 있는 프로그램이다.

---

## 형변환

* 작은 범위에서 큰 범위로는 당연히 값을 넣을 수 있다.

  * 예: `int` → `long` → `double`

* 큰 범위에서 작은 범위로 대입하면 다음과 같은 문제가 발생할 수 있다:

  * 소수점 버림
  * 오버플로우

* 작은 범위 → 큰 범위: \*\*자동 형변환(묵시적 형변환)\*\*이 일어난다.

* 큰 범위 → 작은 범위: **명시적 형변환**이 필요하다.

* 형변환한다고 해서 변수 자체의 타입이 변경되는 것은 아니며, 그 안에 있는 값이 변경되는 것도 아니다.

---

## 오버플로우

* 기존 범위를 초과해서 표현하게 되면 전혀 다른 숫자가 표현되는데, 이런 현상을 **오버플로우**라고 한다.
* 오버플로우가 발생하면 시계가 한 바퀴 돈 것처럼 다시 처음부터 시작한다.
* `int`의 가장 작은 숫자는 `-2147483648`.
* 오버플로우가 발생하는 것 자체가 문제이며, 이를 막는 것이 중요하다.
* 단순히 변수의 타입을 변경해 사이즈를 늘리면 오버플로우 문제를 해결할 수 있다.

---

## 자바에서의 계산

1️⃣ 같은 타입끼리의 계산은 같은 타입의 결과를 낸다.

* 예: `int + int` → `int`, `double + double` → `double`

2️⃣ 서로 다른 타입의 계산은 큰 범위로 자동 형변환이 일어난다.

* 예: `int + long` → `long`, `int + double` → `double`

---

## Scanner의 nextInt()와 nextLine() 차이점

### nextInt()

* 숫자(정수)만 읽고 엔터(\n)는 읽지 않음.
* 예를 들어 1000(엔터)라고 입력하면 1000까지만 읽고, 엔터(\n)는 버퍼에 남음.

### nextLine()

* 한 줄 전체(엔터 포함)를 모두 읽음.
* 예를 들어 사과(엔터)라고 입력하면 "사과"라는 문자열을 반환하고, 엔터(\n)는 소비됨.

---

## iter (향상된 for문 자동완성 단축키)

* `iter`는 IDE(IntelliJ IDEA)에서 for-each문을 자동완성하는 단축키이다.
* 배열이나 컬렉션을 순회할 때 for-each문을 빠르게 작성할 수 있다.

```java
for (타입 변수 : 배열 또는 컬렉션) {
    // 배열 또는 컬렉션의 요소를 순회하며 작업
}
```

---

## 배열

* 같은 타입의 변수를 사용하기 편하게 하나로 묶어둔 것

```java
int[] students; // 배열 선언
students = new int[5]; // 배열 생성
```

### 배열 변수 선언

* 배열 변수를 선언한다고 해서 배열이 바로 생성되지는 않는다.
* 예: `int[] students;`

### 배열 생성

* 배열을 사용하려면 배열을 생성해야 한다.
* 예: `students = new int[5];`
* new는 "새로 생성한다"는 의미.
* 배열 생성 시 값 자동 초기화:

  * 숫자는 0
  * boolean은 false
  * String은 null

### 배열 참조값 보관

* 배열 생성 후 자바는 메모리 어딘가에 배열을 생성하고 참조값(주소)을 반환한다.
* 배열 변수(`students`)에 그 참조값을 저장해 배열에 접근할 수 있다.

### 참조값 확인

* 배열 변수를 출력하면 참조값(주소)를 확인할 수 있다.

---

## 자바의 데이터 타입

* 기본형(primitive type)

  * `int`, `long`, `double`, `boolean` 등
  * 변수에 값을 직접 저장
* 참조형(reference type)

  * 배열(`int[] students`), 객체 등
  * 변수에 참조(주소)를 저장
* 기본형은 선언 시 크기가 고정되며 동적 크기 변경 불가.
* 참조형은 동적 크기 할당 가능하며 더 유연한 데이터 구조를 만들 수 있다.

---

## 리팩토링

* 기존 코드의 기능은 유지하면서 내부 구조를 개선해 가독성과 유지보수성을 높이는 과정.

---

## 배열 리팩토링 - 초기화

### 배열 생성과 동시에 초기화

```java
int[] students;
students = new int[]{90, 80, 70, 60, 50}; // 배열 생성과 초기화

// 혹은 더 간단하게:
int[] students = {90, 80, 70, 60, 50};
```

---

## 2차원 배열

* 행과 열로 구성된 배열

```java
int[][] arr = new int[2][3];
```

### 2차원 배열 리팩토링

```java
int[][] arr = {
    {1, 2, 3},
    {4, 5, 6}
};
```

---

## 향상된 for문 (for-each)

* 배열이나 컬렉션을 순회하며 요소를 하나씩 가져와서 작업

```java
for (타입 변수 : 배열 또는 컬렉션) {
    // 배열 또는 컬렉션의 요소를 순회하면서 수행할 작업
}
