
# 자바 노트 정리

---

## 단축키 (IntelliJ IDEA)

- `Ctrl + N`: 클래스 검색
- `Ctrl + E`: 최근에 사용한 파일 보기
- `Ctrl + E` + `Enter`: 가장 최근 파일 열기
- `Ctrl + Space`: 변수 이름 자동완성, 메서드 자동 완성 등 코드 자동 완성
- `Ctrl + B`: 함수에다 이 단축키를 누르면 해당 함수로 이동

---

## 변수의 종류

- 변수는 선언한 위치에 따라 **지역 변수**, **멤버 변수(클래스 변수, 인스턴스 변수)**로 분류된다.

---

## 지역 변수

- 이름 그대로 특정 지역에서만 사용할 수 있는 변수.
- 특정 지역을 벗어나면 사용할 수 없다.
- 여기서 말하는 특정 지역이 바로 변수가 선언된 코드 블록(`{}`).
- 지역 변수는 자신이 선언된 코드 블록 안에서만 생존하고, 코드 블록을 벗어나면 제거된다.

---

## Java 지역 변수와 중첩 코드 블럭

- **지역 변수(Local Variable)**  
  - 선언된 코드 블럭(`{}`) 안에서만 유효하다.
  - 코드 블럭을 벗어나면 변수는 사라진다.
- **중첩 코드 블럭**  
  - 코드 블럭 안에 또 다른 코드 블럭(`if`, `for`, `while` 등)을 작성할 수 있다.
  - 중첩된 코드 블럭 안에서도 외부 블럭의 변수를 그대로 사용할 수 있다.
- **중첩 코드 블럭에서 변수 이름 중복**  
  - 중첩된 코드 블럭 안에서 외부 코드 블럭과 같은 이름의 변수를 새로 선언하면 컴파일 오류가 발생한다.
  - 대신 외부 변수의 값을 변경하거나 그대로 사용할 수 있다.

---

## 예시 코드

```java
public class ScopeExample {
    public static void main(String[] args) {
        int m = 5; // 외부 블럭에서 선언된 변수

        if (true) {
            // int m = 10;  // 🔥 오류: 이미 외부에 같은 이름의 m이 존재
            m = 10;        // 외부 m의 값을 변경하는 것은 가능
            System.out.println("내부 m: " + m);
        }

        System.out.println("외부 m: " + m);
    }
}
````

---

## 변수의 스코프(Scope)

* 지역 변수는 본인의 코드 블록 안에서만 생존한다.
* 코드 블록을 벗어나면 제거되기 때문에 접근할 수 없다.
* 변수의 접근 가능한 범위를 \*\*스코프(Scope)\*\*라 한다.
* Scope를 번역하면 **범위**라는 뜻이다.
* 변수는 꼭 필요한 범위로 한정해서 사용해야 메모리를 효율적으로 사용하고 유지보수가 쉬워진다.
* 좋은 프로그램은 무한한 자유가 있는 프로그램이 아니라 적절한 제약이 있는 프로그램이다.

---

## 형변환

* 작은 범위에서 큰 범위로는 당연히 값을 넣을 수 있다.

  * 예: `int` → `long` → `double`
* 큰 범위에서 작은 범위로 대입하면 다음과 같은 문제가 발생할 수 있다:

  * 소수점 버림
  * 오버플로우
* 작은 범위 → 큰 범위: \*\*자동 형변환(묵시적 형변환)\*\*이 일어난다.
* 큰 범위 → 작은 범위: **명시적 형변환**이 필요하다.
* 형변환한다고 해서 변수 자체의 타입이 변경되는 것은 아니며, 그 안에 있는 값이 변경되는 것도 아니다.

---

## 오버플로우

* 기존 범위를 초과해서 표현하게 되면 전혀 다른 숫자가 표현되는데, 이런 현상을 **오버플로우**라고 한다.
* 오버플로우가 발생하면 시계가 한 바퀴 돈 것처럼 다시 처음부터 시작한다.
* `int`의 가장 작은 숫자는 `-2147483648`.
* 오버플로우가 발생하는 것 자체가 문제이며, 이를 막는 것이 중요하다.
* 단순히 변수의 타입을 변경해 사이즈를 늘리면 오버플로우 문제를 해결할 수 있다.

---

## 자바에서의 계산

1️⃣ 같은 타입끼리의 계산은 같은 타입의 결과를 낸다.

* 예: `int + int` → `int`, `double + double` → `double`

2️⃣ 서로 다른 타입의 계산은 큰 범위로 자동 형변환이 일어난다.

* 예: `int + long` → `long`, `int + double` → `double`

---

## Scanner의 nextInt()와 nextLine() 차이점

### nextInt()

* 숫자(정수)만 읽고 엔터(`\n`)는 읽지 않음.
* 예를 들어 `1000(엔터)`라고 입력하면 1000까지만 읽고, 엔터(`\n`)는 버퍼에 남음.

### nextLine()

* 한 줄 전체(엔터 포함)를 모두 읽음.
* 예를 들어 `사과(엔터)`라고 입력하면 `"사과"`라는 문자열을 반환하고, 엔터(`\n`)는 소비됨.

---

## iter (향상된 for문 자동완성 단축키)

* `iter`는 IDE(IntelliJ IDEA)에서 for-each문을 자동완성하는 단축키이다.
* 배열이나 컬렉션을 순회할 때 for-each문을 빠르게 작성할 수 있다.

```java
for (타입 변수 : 배열 또는 컬렉션) {
    // 배열 또는 컬렉션의 요소를 순회하며 작업
}
```

---

## 배열

* 같은 타입의 변수를 사용하기 편하게 하나로 묶어둔 것

```java
int[] students; // 배열 선언
students = new int[5]; // 배열 생성
```

### 배열 변수 선언

* 배열 변수를 선언한다고 해서 배열이 바로 생성되지는 않는다.
* 예: `int[] students;`

### 배열 생성

* 배열을 사용하려면 배열을 생성해야 한다.
* 예: `students = new int[5];`
* `new`는 "새로 생성한다"는 의미.
* 배열 생성 시 값 자동 초기화:

  * 숫자는 0
  * boolean은 false
  * String은 null

### 배열 참조값 보관

* 배열 생성 후 자바는 메모리 어딘가에 배열을 생성하고 참조값(주소)을 반환한다.
* 배열 변수(`students`)에 그 참조값을 저장해 배열에 접근할 수 있다.

### 참조값 확인

* 배열 변수를 출력하면 참조값(주소)를 확인할 수 있다.

---

## 자바의 데이터 타입

* **기본형(primitive type)**

  * `int`, `long`, `double`, `boolean` 등
  * 변수에 값을 직접 저장
* **참조형(reference type)**

  * 배열(`int[] students`), 객체 등
  * 변수에 참조(주소)를 저장
* 기본형은 선언 시 크기가 고정되며 동적 크기 변경 불가.
* 참조형은 동적 크기 할당 가능하며 더 유연한 데이터 구조를 만들 수 있다.

---

## 리팩토링

* 기존 코드의 기능은 유지하면서 내부 구조를 개선해 가독성과 유지보수성을 높이는 과정.

---

## 배열 리팩토링 - 초기화

### 배열 생성과 동시에 초기화

```java
int[] students;
students = new int[]{90, 80, 70, 60, 50}; // 배열 생성과 초기화

// 혹은 더 간단하게:
int[] students = {90, 80, 70, 60, 50};
```

---

## 2차원 배열

* 행과 열로 구성된 배열

```java
int[][] arr = new int[2][3];
```

### 2차원 배열 리팩토링

```java
int[][] arr = {
    {1, 2, 3},
    {4, 5, 6}
};
```

---

## 향상된 for문 (for-each)

* 배열이나 컬렉션을 순회하며 요소를 하나씩 가져와서 작업

```java
for (타입 변수 : 배열 또는 컬렉션) {
    // 배열 또는 컬렉션의 요소를 순회하면서 수행할 작업
}
```

---

## Method (메서드)

* 자바에서 함수를 메서드라고 한다. 메서드도 함수의 한 종류라고 생각하면 된다.

### 메서드 선언

```java
public static int add(int a, int b)
```

* 메서드의 선언 부분으로, 메서드 이름, 반환 타입, 매개변수(파라미터) 목록을 포함
* `public static`

  * `public`: 다른 클래스에서 호출할 수 있는 메서드라는 뜻
  * `static`: 객체를 생성하지 않고 호출할 수 있는 정적 메서드라는 뜻
* `int add(int a, int b)`

  * `int`: 반환 타입을 정의. 메서드의 실행 결과를 반환할 때 사용할 반환 타입을 지정
  * `add`: 메서드에 이름을 부여한다.
  * `(int a, int b)`: 메서드 호출할 때 전달하는 입력 값을 정의. 이 변수들은 해당 메서드 안에서만 사용됨. 이렇게 메서드 선언에 사용되는 변수를 영어로 파라미터(parameter), 한글로 매개변수라 함.

---

### 메서드 본문

```java
{
    System.out.println(a + "+" + b + "=" + "연산 수행");
    int sum = a + b;
    return sum;
}
```

* 메서드가 수행해야 하는 코드 블록
* 메서드를 호출하면 메서드 본문이 순서대로 실행
* 메서드 본문은 블랙박스이다. 메서드를 호출하는 곳에서는 메서드 선언은 알지만 메서드 본문은 모름

---

### 메서드 호출

```java
int sum1 = add(5, 10);
```

---

### 메서드 호출과 용어정리

* 메서드를 호출할 때는 다음과 같이 메서드에 넘기는 값과 매개변수의 타입이 맞아야 한다. 물론 넘기는 값과 매개변수의 순서와 갯수도 맞아야 한다.

* **인수(Argument)**

  * 넘기는 값을 영어로 Argument, 한글로 인수 또는 인자라 한다.

* **매개변수(Parameter)**

  * 메서드를 정의할 때 선언한 변수인 `String str`, `int age`를 매개변수, 파라미터라 한다.
  * 메서드를 호출할 때 인수를 넘기면, 그 인수가 매개변수에 대입된다.

---

### 매개변수가 없는 경우

* 선언: `public static void printHeader()`와 같이 매개변수를 비워두고 정의하면 된다.
* 호출: `printHeader();`와 같이 인수를 비워두고 호출하면 된다.

---

### 반환타입이 없는 경우

* 선언: `public static void printHeader()`와 같이 반환 타입을 `void`로 정의하면 된다.

* 호출: `printHeader();`와 같이 반환 타입이 없으므로 메서드만 호출하고 반환 값을 받지 않으면 된다.

* `String str = printHeader();` 반환 타입이 `void`이기 때문에 이렇게 반환 값을 받으면 컴파일 오류가 발생한다.

* 반환 타입이 있는 메서드는 반드시 `return`을 사용해서 값을 반환해야 한다.

* `return` 문을 만나면 그 즉시 메서드를 빠져나간다.

---

### 자바는 항상 변수의 값을 복사해서 대입한다 (중요)

---

## 메서드 오버로딩

* 이름이 같고 매개변수가 다른 메서드를 여러 개 정의하는 것을 메서드 오버로딩이라고 한다.
* 메서드의 이름이 같아도 매개변수의 타입 및 순서가 다르면 오버로딩을 할 수 있다.
* 참고로 반환 타입은 인정하지 않는다.

### 오버로딩 실패

```java
int add(int a, int b)
double add(int a, int b)
```


break: 반복문만 종료하고 메서드는 계속 진행

return: 메서드 자체를 종료하고 호출한 쪽으로 돌아감